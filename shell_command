read
	常用选项: -n(指定接收的字符个数) -s(隐藏输入) -p(后面跟显示信息，类似python里的input) -t(等待时间，超时中断)
	-r (让\转义)
用法示例：
变量引用：
	弱引用变量将保留空白区域,因此若要保留变量中包含空白则需使用弱引用方式: "$variable"而不是直接使用$variable
变量赋值：
	1.variable=`命令`	2.variable=$(命令)
条件测试：
	文件测试选项：
		-e 如果文件存在 -f 如果是一个常规文件(非目录或设备文件)  -s 如果文件长度不为0   -d 如果文件是个目录  -b 文件是个块设备
		-c 文件是个字符设备 -p 文件是个管道  -h 文件是个符号链接 -L 文件是个符号链接  -S 文件是个socket   -t					 关联到一个终端设备的文件描述符，这个选项一般都用来检测是否存在一个给定脚本中的stdin或是一个终端 
		-r 文件具有读权限(对于用户这个test)   -w 文件具有读权限(对于用户这个test)    -x 文件具有执行权限(对于用户这个test) 
		f1 -nt f2 文件1比文件2新   f1 -ot f2 f1比f2老    f1 -ef f2 f1和f2都硬链接到同一个文件
	字符串测试选项：
		-n 字符串不为空,需要若引用变量
		-z 字符串为空，即长度为0
	混合比较：
		-o 逻辑或 -a 逻辑与
变量扩展：
	字符串操作:
		1.${变量名:位置起点} :由指定位置起点开始,截取字符串到字符结束,起点由0开始
		  ${变量名:(负数)或空格负数} :反向提取
		2.${变量名:位置起点:长度} ：由指定的位置起点开始，截取指定长度的字符串,起点由0开始
		  ${*:2} :第二个和后边所有的位置参数
		  ${@:2:3} :从第二个开始，后边的3个位置参数
		  expr substr $string $position $length
		  expr match "$string" "substring" :从字符串开始的位置匹配子串长度,substring是一个正则表达式
		  expr "$string" : "substring" :从字符串开始的位置匹配子串长度,substring是一个正则表达式
		  expr index $string $substring :匹配到子串的第一个字符的位置
		  expr match "$string" '\($substring\)' :从string开始的位置提取$substring,$substring是一个正则表达式
		  expr $string : '\($substring\)'
		3.${#变量名称} :表示返回变量名称的字符串长度
		4.${变量名称#样式} :表示由变量值的最左边开始与样式进行对比，删除"最短相符合的字符串"
		5.${变量名称##样式} :表示由变量最左边开始与样式进行对比,删除"最长相符合的字符串"
		4.${变量名称%样式} ：表示由变量值的最右边开始与样式进行对比，删除"最短相符合的字符串"
		5.${变量名称##样式} :表示由变量最右边开始与样式进行对比,删除"最长相符合的字符串"
		6.${变量/样式/替换字符串} :如果变量中有符合样式的字符串,则使用替换字符串替代,只替换第一个符合样式的字符串
		7.${变量//样式/替换字符串} :如果变量中有符合样式的字符串,则使用替换字符串替代,替换全部符合样式的字符串
		8.${变量名-默认值} :如果变量未定义,则赋给默认值;如果已被定义则不会改变
		  ${变量名:-默认值} :如果变量未定义或变量值为空,则赋给默认值
		  ${变量名+默认值} :如果变量未定义,则不会改变;如果变量已定义,则赋给默认值
		  ${变量名:+默认值} :如果变量未定义或已定义值为空否则使用变量值
		9.: ${变量名?"可指定错误信息"} :检查变量名是否被设置
		10.${!变量名前缀*} :匹配所有前边所有包含变量名前缀的变量
		   ${!变量名前缀@} :匹配所有前边所有包含变量名前缀的变量
		11.declare -r 只读 -f 函数 -i 整数 -a 数组 -x export出 注意:使用declare声明的变量会限制变量的作用域
		.在对比样式时,在样式前加上“#”号,表示该样式要出现在变量的开头才算符合;“%”号则表示结尾
		
echo
	-n(阻止换行) -e(对弱引用中的换行空格起作用)
I/O重定向
	1>filename 重定向stout到filename
	1>>filename 重定向并追加stout到filename
	2>filename 重定向stderr到文件filename
	2>>filename 重定向并追加stderr到filename
	&>filename 将stdout和stderr都重定向到filename
	2>&1 重定向stderr到stdout
	i>&j 重定向文件描述符i到j(指向文件i的所有输出都送到j中去)
	>&j  重定向文件描述符(默认为1,即stdout)到j中去
	0<filename 从文件中接收输入,与">"是成对命令
	[j]<>filename  为了读写filename,把文件filename打开.并且分配文件描述符j给它.如果filename不存在,那么就创建它,如果j没指定则默认是fd 0,stdin
	j>&-关闭已打开的文件描述符j exec n>&j exec 3>&- 类似python中a=read('xx','r') a.close()此方法可避免子shell变量不可存取问题
here document
	1.cat <<标记      2.cat >文本名<<标记(输出到文本)	 3.cat <<-(去掉每行输入内容前边的tab)	 4.cat <<'标记名'(禁止变量转换)
		内容......			内容.....
		.........			......
		标记				标记
	5. 函数 << 标记(提供输入参数)	 6.: << 标记 (注释代码段)  7.产生 自文档化脚本
			变量1							要注释的代码段
			变量...							....
			标记							标记
	注：最后一行必须开始于第一个字符位置,前面不能有任何空白，否则会无法结束
here strings
	COMMAND <<<$word $word将被扩展并且被送入COMMAND的stdin中
TIPS:
	vim 替换命令: s%old%new%(替换一行当中的第一个) s%old%new%g(替换一行当中的全部匹配字符) g%old%new%(全局替换)
	shell循环中如果使用了管道传递参数(eg:ls abc|while read arg)则变量作用域仅限于循环内部

